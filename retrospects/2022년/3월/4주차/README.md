# (기술) 테스트 코드란?

보통 결과물을 내기 위한 프로세스에서 대부분 제일 마지막에 "테스트 및 수정"이라는 과정을 거치게 된다. 여기서 말하는 테스트는 단순히 개발자 혹은 테스터가 결과물에 대한 실제 사용자가 되어 동선을 테스트하는 것일 수도 있다. 하지만 개발자는 자신이 작성한 수 많은 코드를 하나하나 기억하고, 어느 부분에 오류가 발생할 지 추적하며 테스트 하는 시간이 비효율적이다.

이럴 때 보통 "테스트 코드"라고 하는 것을 작성하여 도움을 받을 수 있다.

## 테스트 코드

"테스트 코드"를 작성하지 않은 상태로 개발을 진행하게 되면

1. 개발할 기능이 무엇인지 확인한다.
2. 해당 기능을 작성하기 위한 설계를 진행한다.
3. 설계를 기반으로 소스 코드를 작성한다.
4. 마무리 후 프로그램을 빌드, 실행하여 결과를 직접 확인한다.
5. 원하는 결과물이 나오지 않았을 경우 프로그램을 종료한다.
6. 소스 코드 수정, 재 빌드, 실행의 과정을 계속한다.

위와 같은 순서로 개발을 진행하게 된다.  
어떠한 기능이냐에 따라 다르겠지만, 대체로 이 과정에서는 2번, 5번 과정을 가장 오래 하게 된다.  
여기서 기존에 있던 프로그램에 특정 기능을 더하거나 빼는 작업을 하게 될 때는

1. 추가/제거할 기능을 확인한다.
2. 추가/제거할 기능과 연관(의존)있는 소스 코드를 모두 확인한다.
3. 추가/제거할 기능을 빼기 위해 코드를 새로 정리할 수 있도록 설계한다.
4. 설계를 기반으로 소스 코드를 작성한다. (리팩터링)
5. 마무리 후 프로그램을 빌드, 실행하여 결과를 직접 확인한다.
6. 원하는 결과물이 나오지 않았을 경우 프로그램을 종료한다.
7. 코드를 다시 정리 및 수정(리팩터링), 재 빌드, 실행의 과정을 계속한다.

의 과정을 거치게 되는데, 이렇게 소스 코드를 정리하고, 수정하여 새로운 기능을 받아들일 준비를 하는 행위를 "리팩터링"이라고 한다.  
"리팩터링"을 하다가 보면, 자잘한 소스 한 두 줄 때문에 7번 과정을 해야하는 경우가 생길 수도 있고, 2번 과정을 진행하다가 놓쳐버린 연관(의존)된 소스 코드가 있을 수 있다. 또한 그럴 때, 테스트 과정을 제대로 거치지 않아 오류를 놓쳐버릴 수도 있게 된다.

따라서 이러한 오류들에 대해 프로그램의 어떠한 한 단위에 대해 각각 자동으로 테스트를 진행할 수 있게 해주는 코드가 바로 "테스트 코드"이다.

## 테스트 코드의 효과

테스트는 개발 과정에서 필수적인 프로세스인 만큼 테스트 코드를 작성했을 때의 얻는 이점도 굉장히 많다.

1. 개발 과정에서 문제를 미리 발견할 수 있다.
2. 리팩터링을 안심하고 할 수 있다.
3. 빠른 시간 내에 코드의 동작 방식과 결과를 확인할 수 있다.
4. 좋은 테스트 코드를 연습하다 보면 자연스럽게 좋은 코드가 만들어진다.
5. 의도한 대로 동작되는 것을 자신감 있게 말할 수 있다.
6. 코드에 대한 문서가 될 수 있다.
7. 테스팅에 대한 시간과 비용을 절감할 수 있다.

위와 같은 이점들 외에도 수많은 이점이 있으며, 이에 테스트를 주도적으로 개발을 하는 방법론인 "테스트 주도 개발"(Test Driven Development, `TDD`)라는 기법도 활성화되어 있다.

## 테스트 코드의 적용

일반적으로 테스트는 테스트를 지원하는 모듈과 함께 사용한다.

하지만 테스트 코드는 거창하게 작성하는 코드가 아니다. 간단하게 `n`과 `m`을 파라미터로 전달 받았을 때, 이에 관한 사칙연산을 진행하는 모듈에 관한 테스트 코드를 작성해보자.

```ts
import operation from "./operation";

const n = 10;
const m = 20;

if (operation.add(n, m) === 30) {
  console.log("add 함수 오류 없음.");
}
if (operation.sub(n, m) === -10) {
  console.log("sub 함수 오류 없음.");
}
if (operation.mul(n, m) === 200) {
  console.log("mul 함수 오류 없음.");
}
if (operation.div(n, m) === 0.5) {
  console.log("div 함수 오류 없음.");
}
```

이처럼 `operation` 이라는 모듈과, 모듈 내의 함수를 실행했을 때 의도한 행동과 일치하는 결과가 나오는지 확인하는 코드가 테스트 코드이다.

하지만 이렇게 일일히 메세지를 전부 입력하는 것도 힘들고, 각각 다른 파일에 작성된 모든 테스트를 하나하나 실행시키기도 어렵기 때문에 사용성, 편의성을 위해 테스트를 지원하는 모듈을 사용하게 된다.

때문에 테스트를 지원하는 모듈을 사용할 수 없더라도 테스트 코드를 작성하는 데에는 무리가 없다.

> 테스트 코드의 핵심은 "어떠한 코드의 단위(모듈)이 특정 역할을 수행할 수 있기를 바라고, 역할을 수행했을 때 결과 값이 어떻게 발생하기를 바란다."에 있다.

때문에 기대하는 역할을 수행할 수 없는 코드는 잘못된 코드이며, 테스트를 통과하지 못했다면 해당 모듈을 수정하면 된다는 사실을 알 수 있다.

그러므로 테스트 코드는 기대하는 역할을 잘 정의해 두어야 한다. 너무 간단한 경우 만을 테스트로 작성해두면 예외 처리를 잘 했는지 안 했는지 확인할 수 없으므로 버그 발생 여부를 정확하게 판별하지 못한다.  
위에 작성한 `operation` 모듈에서 `div` 메서드는 두 번째 파라미터인 `m`이 분모의 역할이므로 `0`이면 나눌 수 없기 때문에 동작할 수 없다. 하지만 실제 모듈에서 그러한 예외처리를 안해두었다면 테스트에 작성되지 않아 검증할 수 없으므로 실제 배포 시 오류가 발생하더라도 이상하지 않다.

위에 작성한 한 가지 모듈에 대한 테스트를 "단위 테스트"(`Unit Test`, 유닛 테스트)라고 하는데, 이러한 "단위 테스트"가 만능은 아니다.  
경우의 수가 폭발적으로 증가하는 게임을 예시로 들어보자. "`StarCraft`에서 프로토스 유저가 다크 아칸을 사용해 상대팀 일꾼이 미네랄를 캐서 본진에 갖다 놓는 동시에 일꾼을 마인드 컨트롤 하게 되면 그 미네랄 수치는 상대편에 전달 되어야 하는가? 되면 안되는가?"와 같은 문제가 있을 때, 이 문제는 우선 명쾌한 결과를 설정하는 것이 어렵다.  
문제 발생 후 회의를 진행하여 해당 상황에서 "전달 되어야 한다."라는 결론을 도출한다 하더라도 그 결론에 따라 테스트를 작성하는 것도 일이며, 이 문제는 수만가지 경우의 수의 일부에 불과하다는 것을 감안하면 현실적으로 모든 경우의 수를 예측하는 것이 불가능에 가깝다는 것을 알 수 있다.  
때문에 규모가 큰 프로젝트에서는 단위 테스트 - 통합 테스트 - 시스템 테스트 - 인수 테스트 등의 여러 가지 과정이 있다. 흔히 알고 있는 클로즈 베타, 오픈 베타, 테스트 서버 등이 인수 테스트에 해당한다.

이러한 테스트 과정에서 인수 테스트의 과정에서 조차 발견 되지 않은 버그들이 실제 런칭한 소프트웨어에서 발생하는 것이다.

또한, 테스트는 개발의 시간 증가로 인해 생산성이 저하된다는 치명적인 단점이 있다. 때문에 `SI` 업체에서는 소프트웨어의 품질보다는 납기일 준수가 훨씬 중요하기 때문에 테스트 코드를 잘 작성하지 않게 된다. 생산성 저하는 테스트 코드를 오랫동안 작성하지 않아왔던 사람일수록 더 크게 느껴지기 때문에 테스트 코드 작성을 채택한다고 하더라도 반드시 툴(테스트 프레임워크, 모듈)을 써서 개발해야 된다는 생각, 규칙에 얽매여 있는 테스트 등에 이유로 테스트 작성을 포기하게 된다.

하지만 규모가 큰 프로젝트일수록 테스트 작성은 필수이며, 테스트를 올바르게 작성해야 좋은 소스 코드를 작성할 수 있기 때문에 개발 기술 향상에 있어 불가피한 필수 요소임에는 틀림 없다.
